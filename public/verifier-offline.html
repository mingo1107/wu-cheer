<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ ¸éŠ·ä½œæ¥­ - é›¢ç·šç‰ˆ</title>
    <style>
        /* Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(to bottom right, #eff6ff, #e0e7ff, #f3e8ff);
            min-height: 100vh;
            padding-bottom: 80px;
        }

        /* ç¶²è·¯ç‹€æ…‹æç¤º */
        .network-status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #f59e0b;
            color: white;
            padding: 12px 16px;
            text-align: center;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 14px;
        }

        .network-status::before {
            content: "ğŸ“¶ ";
            margin-right: 8px;
        }

        .network-status.hidden {
            display: none;
        }

        /* é ‚éƒ¨å°èˆª */
        .header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 40;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .operator-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            font-size: 14px;
            color: #374151;
        }

        .operator-info::before {
            content: "ğŸ‘¤ ";
            margin-right: 4px;
        }

        .pending-badge {
            padding: 8px 12px;
            background: #fef3c7;
            color: #92400e;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .pending-badge::before {
            content: "ğŸ’¾ ";
            margin-right: 4px;
        }

        .pending-badge:hover {
            background: #fde68a;
        }

        .pending-badge.hidden {
            display: none;
        }

        /* å®¹å™¨ */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
        }

        /* æ“ä½œè€…è¨­å®šå€ */
        .operator-section {
            max-width: 800px;
            margin: 0 auto 24px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .operator-section h2 {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 16px;
        }

        .operator-form {
            display: flex;
            gap: 12px;
        }

        .operator-form input {
            flex: 1;
            padding: 12px 16px;
            font-size: 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .operator-form input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .operator-form button {
            padding: 12px 24px;
            background: linear-gradient(to right, #3b82f6, #4f46e5);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .operator-form button:hover {
            background: linear-gradient(to right, #2563eb, #4338ca);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }

        .operator-form button:active {
            transform: scale(0.95);
        }

        /* å¡ç‰‡ */
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 24px;
        }

        .card h2 {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 16px;
        }

        /* è¼¸å…¥è¡¨å–® */
        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
        }

        .form-label.barcode::before {
            content: "ğŸ“‹ ";
            margin-right: 4px;
        }

        .input-group {
            display: flex;
            gap: 8px;
        }

        .input-group input {
            flex: 1;
            padding: 14px 16px;
            font-size: 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .input-group button {
            padding: 14px 16px;
            background: #f3f4f6;
            color: #374151;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 18px;
        }

        .input-group button::before {
            content: "ğŸ“·";
        }

        .input-group button:hover {
            background: #e5e7eb;
        }

        /* æŒ‰éˆ• */
        .btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(to right, #3b82f6, #4f46e5);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            touch-action: manipulation;
        }

        .btn.verify::before {
            content: "âœ“ ";
            margin-right: 4px;
        }

        .btn:hover {
            background: linear-gradient(to right, #2563eb, #4338ca);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        /* çµ±è¨ˆè³‡è¨Š */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        @media (min-width: 640px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 16px;
            }
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 16px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
        }

        .stat-value.blue { color: #2563eb; }
        .stat-value.green { color: #16a34a; }
        .stat-value.amber { color: #d97706; }
        .stat-value.red { color: #dc2626; }

        .stat-value i {
            font-style: normal;
        }

        .stat-value.wifi::before { content: "ğŸ“¶"; }
        .stat-value.wifi-off::before { content: "ğŸ“µ"; }

        /* è¨˜éŒ„åˆ—è¡¨ */
        .records-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .records-header h2 {
            margin: 0;
        }

        .refresh-btn {
            padding: 8px 12px;
            font-size: 14px;
            color: #2563eb;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .refresh-btn:hover {
            background: #eff6ff;
        }

        .refresh-btn::before {
            content: "ğŸ”„ ";
            margin-right: 4px;
        }

        .refresh-btn.spinning::before {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 32px;
            color: #6b7280;
        }

        .empty-state::before {
            content: "ğŸ“­";
            font-size: 48px;
            opacity: 0.5;
            display: block;
            margin-bottom: 8px;
        }

        .empty-state.success::before {
            content: "âœ…";
        }

        .records-list {
            max-height: 384px;
            overflow-y: auto;
        }

        .record-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .record-info {
            flex: 1;
            min-width: 0;
        }

        .record-barcode {
            font-weight: 500;
            color: #1f2937;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .record-time {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .record-status {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 9999px;
            margin-left: 12px;
        }

        .status-synced {
            background: #d1fae5;
            color: #065f46;
        }

        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }

        .status-failed {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 25px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 448px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h3 {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
        }

        .modal-close {
            padding: 8px;
            color: #9ca3af;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: #6b7280;
        }

        .modal-body {
            padding: 16px;
        }

        .modal-footer {
            padding: 16px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
        }

        .modal-footer button {
            flex: 1;
        }

        /* Toast é€šçŸ¥ */
        .toast-container {
            position: fixed;
            top: 60px;
            right: 16px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            padding: 12px 16px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-width: 300px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.success::before {
            content: "âœ“ ";
            color: #10b981;
            font-size: 20px;
            font-weight: bold;
        }

        .toast.error::before {
            content: "âœ— ";
            color: #ef4444;
            font-size: 20px;
            font-weight: bold;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* è¼‰å…¥å‹•ç•« */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        /* æ‰‹æ©Ÿç‰ˆå„ªåŒ– */
        @media (max-width: 640px) {
            input[type="text"] {
                font-size: 16px !important;
            }

            .modal {
                border-radius: 16px 16px 0 0;
                max-height: 80vh;
            }
        }

        /* éš±è—é¡åˆ¥ */
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <!-- ç¶²è·¯ç‹€æ…‹æç¤º -->
    <div id="networkStatus" class="network-status hidden">
        é›¢ç·šæ¨¡å¼ï¼šè³‡æ–™å°‡æš«å­˜åœ¨æœ¬åœ°
    </div>

    <!-- é ‚éƒ¨å°èˆª -->
    <div class="header">
        <div class="header-content">
            <h1>æ ¸éŠ·ä½œæ¥­</h1>
            <div class="header-actions">
                <div id="operatorInfo" class="operator-info hidden">
                    <span id="operatorName"></span>
                </div>
                <button id="pendingBadge" class="pending-badge hidden" onclick="showOfflineRecords()">
                    å¾…åŒæ­¥ <span id="pendingCount">0</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- æ“ä½œè€…è¨­å®šå€ -->
        <div id="operatorSection" class="operator-section">
            <h2>è«‹è¼¸å…¥æ“ä½œè€…å¸³è™Ÿ</h2>
            <form class="operator-form" onsubmit="setOperator(event)">
                <input 
                    type="text" 
                    id="operatorInput" 
                    placeholder="è«‹è¼¸å…¥æ“ä½œè€…å¸³è™Ÿ" 
                    required
                    autocomplete="off"
                >
                <button type="submit">ç¢ºèª</button>
            </form>
        </div>

        <!-- æ ¸éŠ·è¼¸å…¥å€ -->
        <div id="verifySection" class="card hidden">
            <h2>è¼¸å…¥ Barcode</h2>
            <form onsubmit="handleVerify(event)">
                <div class="form-group">
                    <label class="form-label barcode">
                        Barcode
                    </label>
                    <div class="input-group">
                        <input 
                            type="text" 
                            id="barcodeInput" 
                            placeholder="è«‹è¼¸å…¥æˆ–æƒæ barcode" 
                            required
                            autocomplete="off"
                        >
                        <button type="button" onclick="startScan()" title="æƒææ¢ç¢¼"></button>
                    </div>
                </div>
                <button type="submit" class="btn verify" id="verifyBtn">
                    æ ¸éŠ·
                </button>
            </form>
        </div>

        <!-- çµ±è¨ˆè³‡è¨Š -->
        <div id="statsSection" class="stats-grid hidden">
            <div class="stat-card">
                <div class="stat-value blue" id="todayCount">0</div>
                <div class="stat-label">ä»Šæ—¥æ ¸éŠ·</div>
            </div>
            <div class="stat-card">
                <div class="stat-value green" id="totalCount">0</div>
                <div class="stat-label">ç¸½è¨ˆ</div>
            </div>
            <div class="stat-card">
                <div class="stat-value amber" id="pendingStat">0</div>
                <div class="stat-label">å¾…åŒæ­¥</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="networkStatusIcon">
                    <span class="wifi"></span>
                </div>
                <div class="stat-label" id="networkStatusText">åœ¨ç·š</div>
            </div>
        </div>

        <!-- æœ€è¿‘æ ¸éŠ·è¨˜éŒ„ -->
        <div id="recordsSection" class="card hidden">
            <div class="records-header">
                <h2>æœ€è¿‘æ ¸éŠ·è¨˜éŒ„</h2>
                <button class="refresh-btn" onclick="refreshRecords()" id="refreshBtn">
                    é‡æ•´
                </button>
            </div>
            <div id="recordsList" class="records-list">
                <!-- è¨˜éŒ„å°‡å‹•æ…‹æ’å…¥é€™è£¡ -->
            </div>
        </div>
    </div>

    <!-- é›¢ç·šè¨˜éŒ„ Modal -->
    <div id="offlineModal" class="modal-overlay hidden" onclick="if(event.target === this) closeOfflineModal()">
        <div class="modal">
            <div class="modal-header">
                <h3>å¾…åŒæ­¥è¨˜éŒ„</h3>
                <button class="modal-close" onclick="closeOfflineModal()" title="é—œé–‰">âœ•</button>
            </div>
            <div class="modal-body">
                <div id="offlineRecordsList">
                    <!-- é›¢ç·šè¨˜éŒ„å°‡å‹•æ…‹æ’å…¥é€™è£¡ -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeOfflineModal()">é—œé–‰</button>
                <button class="btn" onclick="syncOfflineRecords()" id="syncBtn" disabled>
                    åŒæ­¥è¨˜éŒ„
                </button>
            </div>
        </div>
    </div>

    <!-- æ ¸éŠ·ç¢ºèª Dialog -->
    <div id="verifyDialog" class="modal-overlay hidden" onclick="if(event.target === this) cancelVerify()">
        <div class="modal">
            <div class="modal-header">
                <h3>ç¢ºèªæ ¸éŠ·è³‡è¨Š</h3>
                <button class="modal-close" onclick="cancelVerify()" title="é—œé–‰">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Barcode</label>
                    <div style="padding: 12px; background: #f9fafb; border-radius: 8px; font-family: monospace; font-size: 14px;" id="verifyBarcodeDisplay"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">
                        è»Šè™Ÿ <span style="color: #ef4444;">*</span>
                    </label>
                    <select id="vehicleSelect" class="input-group input" required style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 8px;">
                        <option value="">è«‹é¸æ“‡è»Šè™Ÿ</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">
                        å¸æ©Ÿåå­— <span style="color: #ef4444;">*</span>
                    </label>
                    <input 
                        type="text" 
                        id="driverNameInput" 
                        placeholder="è«‹è¼¸å…¥å¸æ©Ÿåå­—" 
                        required
                        autocomplete="off"
                        class="input-group input"
                        style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 8px;"
                    >
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="cancelVerify()">å–æ¶ˆ</button>
                <button class="btn" onclick="confirmVerify()" id="confirmBtn" disabled>
                    ç¢ºèªæ ¸éŠ·
                </button>
            </div>
        </div>
    </div>

    <!-- Toast å®¹å™¨ -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
        // ==================== å…¨åŸŸè®Šæ•¸ ====================
        const STORAGE_KEY = 'verifier_offline_records';
        const OPERATOR_KEY = 'verifier_operator';
        const API_BASE_URL = window.location.origin + '/api/verifier-platform';

        let operator = localStorage.getItem(OPERATOR_KEY) || '';
        let isOnline = navigator.onLine;
        let recentRecords = [];
        let offlineRecords = [];
        let stats = { today: 0, total: 0 };
        let verifyBarcode = '';
        let verifyVehicles = [];
        let isVerifying = false;
        let isPreChecking = false;

        // ==================== åˆå§‹åŒ– ====================
        document.addEventListener('DOMContentLoaded', () => {
            // æª¢æŸ¥æ“ä½œè€…
            if (operator) {
                setOperatorUI(operator);
            }

            // ç›£è½ç¶²è·¯ç‹€æ…‹
            window.addEventListener('online', handleNetworkOnline);
            window.addEventListener('offline', handleNetworkOffline);
            updateNetworkStatus();

            // è¼‰å…¥è³‡æ–™
            loadOfflineRecords();
            refreshRecords();

            // è‡ªå‹•èšç„¦
            const operatorInput = document.getElementById('operatorInput');
            const barcodeInput = document.getElementById('barcodeInput');
            if (operatorInput && !operator) {
                setTimeout(() => operatorInput.focus(), 100);
            } else if (barcodeInput && operator) {
                setTimeout(() => barcodeInput.focus(), 100);
            }
        });

        // ==================== æ“ä½œè€…ç®¡ç† ====================
        function setOperator(event) {
            event.preventDefault();
            const input = document.getElementById('operatorInput');
            const operatorName = input.value.trim();
            
            if (!operatorName) {
                showToast('è«‹è¼¸å…¥æ“ä½œè€…å¸³è™Ÿ', 'error');
                return;
            }

            operator = operatorName;
            localStorage.setItem(OPERATOR_KEY, operator);
            setOperatorUI(operator);
            showToast('æ“ä½œè€…è¨­å®šæˆåŠŸ', 'success');
        }

        function setOperatorUI(operatorName) {
            document.getElementById('operatorSection').classList.add('hidden');
            document.getElementById('verifySection').classList.remove('hidden');
            document.getElementById('statsSection').classList.remove('hidden');
            document.getElementById('recordsSection').classList.remove('hidden');
            
            document.getElementById('operatorInfo').classList.remove('hidden');
            document.getElementById('operatorName').textContent = operatorName;
        }

        // ==================== ç¶²è·¯ç‹€æ…‹ ====================
        function updateNetworkStatus() {
            const statusEl = document.getElementById('networkStatus');
            const iconEl = document.getElementById('networkStatusIcon');
            const textEl = document.getElementById('networkStatusText');
            
            if (isOnline) {
                statusEl.classList.add('hidden');
                iconEl.className = 'stat-value green wifi';
                iconEl.innerHTML = '<span class="wifi"></span>';
                textEl.textContent = 'åœ¨ç·š';
            } else {
                statusEl.classList.remove('hidden');
                iconEl.className = 'stat-value red wifi-off';
                iconEl.innerHTML = '<span class="wifi-off"></span>';
                textEl.textContent = 'é›¢ç·š';
            }
        }

        function handleNetworkOnline() {
            isOnline = true;
            updateNetworkStatus();
            if (offlineRecords.length > 0) {
                showToast('ç¶²è·¯å·²æ¢å¾©ï¼Œå¯ä»¥é€²è¡ŒåŒæ­¥', 'success');
            }
        }

        function handleNetworkOffline() {
            isOnline = false;
            updateNetworkStatus();
        }

        // ==================== æ ¸éŠ·è™•ç† ====================
        async function handleVerify(event) {
            event.preventDefault();
            
            if (!operator) {
                showToast('è«‹å…ˆè¨­å®šæ“ä½œè€…å¸³è™Ÿ', 'error');
                return;
            }

            const barcodeInput = document.getElementById('barcodeInput');
            const barcode = barcodeInput.value.trim();

            if (!barcode) {
                return;
            }

            isPreChecking = true;
            const verifyBtn = document.getElementById('verifyBtn');
            verifyBtn.disabled = true;
            verifyBtn.innerHTML = '<span class="spinner"></span> è™•ç†ä¸­...';

            try {
                if (isOnline) {
                    // åœ¨ç·šæ¨¡å¼ï¼šé æª¢æŸ¥
                    const result = await apiCall('POST', '/verify/pre-check', { barcode });
                    
                    if (result.status && result.data) {
                        verifyBarcode = barcode;
                        verifyVehicles = result.data.vehicles || [];
                        showVerifyDialog();
                    } else {
                        showToast(result.message || 'Barcode é©—è­‰å¤±æ•—', 'error');
                    }
                } else {
                    // é›¢ç·šæ¨¡å¼ï¼šç›´æ¥å„²å­˜
                    const id = saveOfflineRecord({
                        barcode,
                        operator_account: operator,
                        operator_name: operator
                    });
                    
                    showToast('å·²å„²å­˜åˆ°é›¢ç·šè¨˜éŒ„ï¼Œå¾…ç¶²è·¯æ¢å¾©å¾Œè‡ªå‹•åŒæ­¥', 'success');
                    addRecentRecord({
                        id,
                        barcode,
                        status: 'pending',
                        created_at: new Date().toISOString()
                    });
                    loadOfflineRecords();
                    barcodeInput.value = '';
                    setTimeout(() => barcodeInput.focus(), 100);
                }
            } catch (error) {
                showToast(error.message || 'é æª¢æŸ¥å¤±æ•—', 'error');
            } finally {
                isPreChecking = false;
                verifyBtn.disabled = false;
                verifyBtn.innerHTML = '<i class="fas fa-check-circle"></i> æ ¸éŠ·';
            }
        }

        function showVerifyDialog() {
            document.getElementById('verifyBarcodeDisplay').textContent = verifyBarcode;
            
            const vehicleSelect = document.getElementById('vehicleSelect');
            vehicleSelect.innerHTML = '<option value="">è«‹é¸æ“‡è»Šè™Ÿ</option>';
            verifyVehicles.forEach(vehicle => {
                const option = document.createElement('option');
                option.value = vehicle.id;
                const plateText = vehicle.front_plate + (vehicle.rear_plate ? ' / ' + vehicle.rear_plate : '');
                option.textContent = `${plateText} (${vehicle.cleaner_name})`;
                vehicleSelect.appendChild(option);
            });

            document.getElementById('driverNameInput').value = '';
            document.getElementById('verifyDialog').classList.remove('hidden');
            updateConfirmButton();
        }

        function cancelVerify() {
            document.getElementById('verifyDialog').classList.add('hidden');
            verifyBarcode = '';
            verifyVehicles = [];
            const barcodeInput = document.getElementById('barcodeInput');
            setTimeout(() => barcodeInput.focus(), 100);
        }

        function updateConfirmButton() {
            const vehicleSelect = document.getElementById('vehicleSelect');
            const driverNameInput = document.getElementById('driverNameInput');
            const confirmBtn = document.getElementById('confirmBtn');
            
            const isValid = vehicleSelect.value && driverNameInput.value.trim();
            confirmBtn.disabled = !isValid || isVerifying;
        }

        document.getElementById('vehicleSelect')?.addEventListener('change', updateConfirmButton);
        document.getElementById('driverNameInput')?.addEventListener('input', updateConfirmButton);

        async function confirmVerify() {
            if (!verifyBarcode) return;

            const vehicleSelect = document.getElementById('vehicleSelect');
            const driverNameInput = document.getElementById('driverNameInput');

            if (!vehicleSelect.value) {
                showToast('è«‹é¸æ“‡è»Šè™Ÿ', 'error');
                return;
            }

            if (!driverNameInput.value.trim()) {
                showToast('è«‹è¼¸å…¥å¸æ©Ÿåå­—', 'error');
                return;
            }

            isVerifying = true;
            const confirmBtn = document.getElementById('confirmBtn');
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '<span class="spinner"></span> æ ¸éŠ·ä¸­...';

            try {
                const result = await apiCall('POST', '/verify', {
                    barcode: verifyBarcode,
                    vehicle_id: parseInt(vehicleSelect.value),
                    driver_name: driverNameInput.value.trim()
                });

                if (result.status && result.data) {
                    showToast('æ ¸éŠ·æˆåŠŸ', 'success');
                    addRecentRecord({
                        barcode: verifyBarcode,
                        status: 'synced',
                        created_at: new Date().toISOString()
                    });
                    await loadStats();
                    cancelVerify();
                    document.getElementById('barcodeInput').value = '';
                    setTimeout(() => document.getElementById('barcodeInput').focus(), 100);
                } else {
                    showToast(result.message || 'æ ¸éŠ·å¤±æ•—', 'error');
                }
            } catch (error) {
                showToast(error.message || 'æ ¸éŠ·å¤±æ•—', 'error');
            } finally {
                isVerifying = false;
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = 'ç¢ºèªæ ¸éŠ·';
            }
        }

        // ==================== é›¢ç·šè¨˜éŒ„ç®¡ç† ====================
        function getAllRecords() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('è®€å–é›¢ç·šè¨˜éŒ„å¤±æ•—:', error);
                return [];
            }
        }

        function saveOfflineRecord(record) {
            try {
                const records = getAllRecords();
                const id = Date.now();
                const newRecord = {
                    id,
                    ...record,
                    created_at: new Date().toISOString(),
                    status: 'pending'
                };
                records.push(newRecord);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(records));
                return id;
            } catch (error) {
                console.error('å„²å­˜é›¢ç·šè¨˜éŒ„å¤±æ•—:', error);
                throw error;
            }
        }

        function getPendingRecords() {
            const allRecords = getAllRecords();
            return allRecords.filter(record => record.status === 'pending');
        }

        function updateRecordStatus(id, status) {
            try {
                const records = getAllRecords();
                const index = records.findIndex(r => r.id === id);
                if (index === -1) return false;
                records[index].status = status;
                records[index].updated_at = new Date().toISOString();
                localStorage.setItem(STORAGE_KEY, JSON.stringify(records));
                return true;
            } catch (error) {
                console.error('æ›´æ–°è¨˜éŒ„ç‹€æ…‹å¤±æ•—:', error);
                return false;
            }
        }

        function loadOfflineRecords() {
            offlineRecords = getPendingRecords();
            const pendingCount = offlineRecords.length;
            
            document.getElementById('pendingCount').textContent = pendingCount;
            document.getElementById('pendingStat').textContent = pendingCount;
            
            if (pendingCount > 0) {
                document.getElementById('pendingBadge').classList.remove('hidden');
            } else {
                document.getElementById('pendingBadge').classList.add('hidden');
            }
        }

        function showOfflineRecords() {
            const listEl = document.getElementById('offlineRecordsList');
            
            if (offlineRecords.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state success">
                        <p>æ‰€æœ‰è¨˜éŒ„å·²åŒæ­¥</p>
                    </div>
                `;
            } else {
                listEl.innerHTML = offlineRecords.map(record => `
                    <div class="record-item">
                        <div class="record-info">
                            <div class="record-barcode">${escapeHtml(record.barcode)}</div>
                            <div class="record-time">${formatDateTimeShort(record.created_at)}</div>
                        </div>
                    </div>
                `).join('');
            }

            const syncBtn = document.getElementById('syncBtn');
            syncBtn.disabled = !isOnline || offlineRecords.length === 0;
            
            document.getElementById('offlineModal').classList.remove('hidden');
        }

        function closeOfflineModal() {
            document.getElementById('offlineModal').classList.add('hidden');
        }

        async function syncOfflineRecords() {
            if (!isOnline) {
                showToast('ç¶²è·¯æœªé€£ç·šï¼Œç„¡æ³•åŒæ­¥', 'error');
                return;
            }

            const pending = getPendingRecords();
            if (pending.length === 0) {
                showToast('æ²’æœ‰å¾…åŒæ­¥çš„è¨˜éŒ„', 'success');
                return;
            }

            const syncBtn = document.getElementById('syncBtn');
            syncBtn.disabled = true;
            syncBtn.innerHTML = '<span class="spinner"></span> åŒæ­¥ä¸­...';

            try {
                const barcodes = pending.map(record => record.barcode);
                const result = await apiCall('POST', '/verify/batch', { barcodes });

                if (result.status && result.data) {
                    const { success, failed, errors } = result.data;
                    const errorBarcodes = errors.map(e => e.barcode);
                    
                    pending.forEach(record => {
                        if (errorBarcodes.includes(record.barcode)) {
                            updateRecordStatus(record.id, 'failed');
                        } else {
                            updateRecordStatus(record.id, 'synced');
                        }
                    });

                    if (failed === 0) {
                        showToast(`åŒæ­¥å®Œæˆï¼šæˆåŠŸ ${success} ç­†`, 'success');
                    } else {
                        showToast(`åŒæ­¥å®Œæˆï¼šæˆåŠŸ ${success} ç­†ï¼Œå¤±æ•— ${failed} ç­†`, 'error');
                    }

                    loadOfflineRecords();
                    await loadStats();
                    refreshRecords();
                    closeOfflineModal();
                } else {
                    showToast(result.message || 'åŒæ­¥å¤±æ•—', 'error');
                }
            } catch (error) {
                showToast(error.message || 'åŒæ­¥å¤±æ•—', 'error');
            } finally {
                syncBtn.disabled = false;
                syncBtn.innerHTML = 'åŒæ­¥è¨˜éŒ„';
            }
        }

        // ==================== è¨˜éŒ„é¡¯ç¤º ====================
        function addRecentRecord(record) {
            recentRecords.unshift(record);
            if (recentRecords.length > 20) {
                recentRecords = recentRecords.slice(0, 20);
            }
            renderRecords();
        }

        function renderRecords() {
            const listEl = document.getElementById('recordsList');
            
            if (recentRecords.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <p>å°šç„¡æ ¸éŠ·è¨˜éŒ„</p>
                    </div>
                `;
            } else {
                listEl.innerHTML = recentRecords.map(record => {
                    const statusClass = record.status === 'synced' ? 'status-synced' : 
                                      record.status === 'pending' ? 'status-pending' : 'status-failed';
                    const statusText = record.status === 'synced' ? 'å·²åŒæ­¥' : 
                                      record.status === 'pending' ? 'å¾…åŒæ­¥' : 'å¤±æ•—';
                    
                    return `
                        <div class="record-item">
                            <div class="record-info">
                                <div class="record-barcode">${escapeHtml(record.barcode)}</div>
                                <div class="record-time">${formatDateTimeShort(record.created_at)}</div>
                            </div>
                            <span class="record-status ${statusClass}">${statusText}</span>
                        </div>
                    `;
                }).join('');
            }
        }

        async function refreshRecords() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.classList.add('spinning');
            
            try {
                loadOfflineRecords();
                await loadStats();
            } catch (error) {
                showToast('è¼‰å…¥å¤±æ•—', 'error');
            } finally {
                refreshBtn.classList.remove('spinning');
            }
        }

        // ==================== çµ±è¨ˆè³‡è¨Š ====================
        async function loadStats() {
            try {
                if (isOnline) {
                    // æ³¨æ„ï¼šé€™å€‹ API éœ€è¦ tokenï¼Œé›¢ç·šç‰ˆå¯èƒ½ç„¡æ³•ä½¿ç”¨
                    // å¯ä»¥è€ƒæ…®ç§»é™¤æˆ–ä½¿ç”¨æœ¬åœ°çµ±è¨ˆ
                    const allRecords = getAllRecords();
                    stats.total = allRecords.filter(r => r.status === 'synced').length;
                    stats.today = allRecords.filter(r => {
                        if (r.status !== 'synced') return false;
                        const recordDate = new Date(r.created_at);
                        const today = new Date();
                        return recordDate.toDateString() === today.toDateString();
                    }).length;
                } else {
                    const allRecords = getAllRecords();
                    stats.total = allRecords.filter(r => r.status === 'synced').length;
                    stats.today = 0;
                }
                
                document.getElementById('todayCount').textContent = stats.today || 0;
                document.getElementById('totalCount').textContent = stats.total || 0;
            } catch (error) {
                console.error('è¼‰å…¥çµ±è¨ˆå¤±æ•—:', error);
            }
        }

        // ==================== API èª¿ç”¨ ====================
        async function apiCall(method, endpoint, data = null) {
            const url = API_BASE_URL + endpoint;
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            };

            if (data) {
                options.body = JSON.stringify(data);
            }

            try {
                const response = await fetch(url, options);
                const result = await response.json();
                return result;
            } catch (error) {
                throw new Error('ç¶²è·¯è«‹æ±‚å¤±æ•—ï¼š' + error.message);
            }
        }

        // ==================== å·¥å…·å‡½æ•¸ ====================
        function formatDateTimeShort(dateString) {
            if (!dateString) return '-';
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return '-';
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${year}/${month}/${day} ${hours}:${minutes}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            toast.innerHTML = `<span>${escapeHtml(message)}</span>`;
            
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function startScan() {
            showToast('æ¢ç¢¼æƒæåŠŸèƒ½é–‹ç™¼ä¸­', 'error');
        }
    </script>

    <!-- æ‰€æœ‰æ¨£å¼å·²å…§åµŒï¼Œç„¡éœ€å¤–éƒ¨è³‡æº -->
</body>
</html>

